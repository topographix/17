import { useState, useEffect, useRef } from "react";
import { useParams, useLocation } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Textarea } from "@/components/ui/textarea";
import { ArrowLeft, Send, Settings, ImagePlus, User2, X } from "lucide-react";
import { Toaster } from "@/components/ui/toaster";
import { useToast } from "@/hooks/use-toast";
import { Skeleton } from "@/components/ui/skeleton";
import type { Companion, UserPreferences } from "@shared/schema";
import { useAuth } from "@/hooks/use-auth";
import DiamondCounter from "@/components/DiamondCounter";
import { queryClient, apiRequest } from "@/lib/queryClient";
import ImageGenerator from "@/components/ImageGenerator";
import CompanionSettingsPopup from "@/components/CompanionSettingsPopup";

import { analyzeEmotion, getEmotionalResponse, EmotionAnalysisResult } from "@/lib/emotionDetection";
import EmotionIndicator from "@/components/EmotionIndicator";

interface Message {
  id: string;
  content: string;
  sender: "user" | "companion";
  timestamp: Date;
  emotion?: EmotionAnalysisResult;
  emotionalResponse?: string;
  imageUrl?: string;
}

// Generate a unique ID for messages
const generateId = () => Math.random().toString(36).substr(2, 9);

export default function Chat() {
  const { id } = useParams();
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const { user } = useAuth();
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [message, setMessage] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);
  const [searchResults, setSearchResults] = useState<number[]>([]);
  const [currentSearchResultIndex, setCurrentSearchResultIndex] = useState(-1);
  const [guestMessageCount, setGuestMessageCount] = useState(0);
  const [showImageGenerator, setShowImageGenerator] = useState(false);
  const [showProfilePicture, setShowProfilePicture] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  
  // Fetch the companion data
  const { data: companion, isLoading: isLoadingCompanion } = useQuery<Companion>({
    queryKey: [`/api/companions/${id}`],
    retry: false,
  });
  
  // Fetch user preferences to get diamond count
  const { data: userPrefs, isLoading: isLoadingPrefs } = useQuery<UserPreferences>({
    queryKey: [`/api/user/preferences`],
    enabled: !!user,
  });
  
  // Update message diamond count mutation
  const updateDiamondsMutation = useMutation({
    mutationFn: async (updatedDiamonds: number) => {
      const res = await apiRequest('PATCH', '/api/user/preferences', { 
        messageDiamonds: updatedDiamonds 
      });
      
      return await res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/user/preferences`] });
    },
    onError: () => {
      toast({
        title: 'Error',
        description: 'Failed to update message diamonds',
        variant: 'destructive'
      });
    }
  });

  // Load previous messages from localStorage
  useEffect(() => {
    if (id) {
      const storedMessages = localStorage.getItem(`chat_${id}`);
      if (storedMessages) {
        try {
          const parsedMessages = JSON.parse(storedMessages);
          // Convert string timestamps back to Date objects
          const messagesWithDateObjects = parsedMessages.map((msg: any) => ({
            ...msg,
            timestamp: new Date(msg.timestamp)
          }));
          setMessages(messagesWithDateObjects);
        } catch (error) {
          console.error("Failed to parse stored messages:", error);
        }
      } else if (companion && companion.name && companion.tagline) {
        // If no previous messages, add a welcome message
        setMessages([
          {
            id: generateId(),
            content: `Hi there! I'm ${companion.name}. ${companion.tagline} How can I make your day better?`,
            sender: "companion",
            timestamp: new Date()
          }
        ]);
      }
    }
    
    // Load guest message count
    if (!user) {
      const count = parseInt(localStorage.getItem('guestMessageCount') || '0', 10);
      setGuestMessageCount(count);
    }
  }, [id, companion, user]);

  // Save messages to localStorage whenever they change
  useEffect(() => {
    if (id && messages.length > 0) {
      localStorage.setItem(`chat_${id}`, JSON.stringify(messages));
    }
  }, [messages, id]);

  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSendMessage = async () => {
    if (!message.trim()) return;
    
    // Track message count in localStorage if not logged in
    let localMessageCount = 0;
    if (!user) {
      localMessageCount = parseInt(localStorage.getItem('guestMessageCount') || '0', 10);
      setGuestMessageCount(localMessageCount + 1);
      if (localMessageCount >= 100) {
        toast({
          title: "Free message limit reached",
          description: "You've used all your free messages. Please sign up to continue chatting.",
          variant: "destructive"
        });
        return;
      }
    } else if (userPrefs && typeof userPrefs.messageDiamonds === 'number' && userPrefs.messageDiamonds <= 0) {
      // Check if logged-in user has diamonds left
      toast({
        title: "Out of free messages",
        description: "You've used all your free messages. Please subscribe to continue chatting.",
        variant: "destructive"
      });
      return;
    }
    
    // Analyze message for emotional content
    const detectedEmotion = analyzeEmotion(message);
    
    // Add user message with emotion data
    const userMessage: Message = {
      id: generateId(),
      content: message,
      sender: "user",
      timestamp: new Date(),
      emotion: detectedEmotion
    };
    
    setMessages(prev => [...prev, userMessage]);
    setMessage("");
    setIsLoading(true);
    
    // Update message count
    if (!user) {
      // For guest users, store in localStorage
      localStorage.setItem('guestMessageCount', (localMessageCount + 1).toString());
    } else if (userPrefs && typeof userPrefs.messageDiamonds === 'number' && userPrefs.messageDiamonds > 0) {
      // For logged-in users, update in database
      const newDiamondCount = userPrefs.messageDiamonds - 1;
      updateDiamondsMutation.mutate(newDiamondCount);
    }
    
    // Record interaction for heatmap visualization
    if (id) {
      try {
        const now = new Date();
        // Record basic interaction with emotion data if available
        fetch('/api/interactions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            companionId: parseInt(id),
            userId: user?.id || null,
            date: now,
            hour: now.getHours(),
            messageCount: 1,
            emotionType: detectedEmotion.primaryEmotion.type,
            emotionIntensity: detectedEmotion.primaryEmotion.confidence,
            responseTimeMs: null // Will be populated on response
          }),
        }).catch(err => console.error('Failed to record interaction:', err));
      } catch (error) {
        console.error('Error recording interaction:', error);
        // Non-blocking, continue even if recording fails
      }
    }
    
    // Used to simulate realistic typing behavior
    const calculateTypingDelay = (text: string) => {
      // Average adult typing speed is 40 WPM, or about 200 characters per minute
      // This is about 3.33 characters per second
      const avgCharPerSec = 3.33;
      // Add randomness to make it feel more natural
      const randomFactor = 0.7 + Math.random() * 0.6; // Between 0.7 and 1.3
      const delay = (text.length / avgCharPerSec) * 1000 * randomFactor;
      // Ensure minimum delay of 1.5 seconds and max of 6 seconds
      return Math.min(Math.max(delay, 1500), 6000);
    };
    
    // Use the new chat API with memory feature
    const sessionId = localStorage.getItem('chatSessionId') || `session_${Math.random().toString(36).substring(2, 9)}`;
    
    // Store session ID for guest users
    if (!localStorage.getItem('chatSessionId')) {
      localStorage.setItem('chatSessionId', sessionId);
    }
    
    // Prepare emotion data for API
    const emotion = {
      type: detectedEmotion.primaryEmotion.type,
      intensity: detectedEmotion.primaryEmotion.confidence.toString(),
      confidence: detectedEmotion.primaryEmotion.confidence
    };
    
    // Call the chat API
    setTimeout(() => {
      fetch(`/api/companions/${id}/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message,
          userId: user?.id,
          sessionId: user ? undefined : sessionId, // Only use sessionId for guest users
          emotion
        })
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        // Calculate typing delay to make it feel natural
        const typingDelay = calculateTypingDelay(data.text);
        
        // After delay, show the companion's response
        setTimeout(() => {
          // Create companion message
          const companionMessage: Message = {
            id: generateId(),
            content: data.text,
            sender: "companion",
            timestamp: new Date(),
            emotion: data.emotion ? {
              primaryEmotion: {
                type: data.emotion,
                intensity: 'medium',
                confidence: 0.9
              },
              secondaryEmotion: {
                type: 'neutral',
                intensity: 'low',
                confidence: 0.1
              },
              overall: 'neutral'
            } : undefined
          };
          
          // Update message state
          setMessages(prev => [...prev, companionMessage]);
          
          // If we have memory context, log it (for development)
          if (data.memoryContext) {
            console.log('Memory context used:', data.memoryContext);
          }
          
          // Record interaction end time for response time tracking
          if (id) {
            try {
              const responseTime = Date.now() - new Date(userMessage.timestamp).getTime();
              fetch('/api/interactions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  companionId: parseInt(id),
                  userId: user?.id || null,
                  messageCount: 1,
                  responseTimeMs: responseTime
                }),
              }).catch(err => console.error('Failed to record response time:', err));
            } catch (error) {
              console.error('Error recording response time:', error);
            }
          }
          
          setIsLoading(false);
        }, typingDelay);
      })
      .catch(error => {
        console.error('Error calling chat API:', error);
        toast({
          title: "Failed to get response",
          description: "There was a problem communicating with your companion. Please try again.",
          variant: "destructive"
        });
        setIsLoading(false);
      });
    }, 500);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };
  
  // Search functionality
  const handleSearch = () => {
    if (!searchQuery.trim()) {
      setSearchResults([]);
      setCurrentSearchResultIndex(-1);
      return;
    }
    
    const query = searchQuery.toLowerCase();
    const results: number[] = [];
    
    messages.forEach((msg, index) => {
      if (msg.content.toLowerCase().includes(query)) {
        results.push(index);
      }
    });
    
    setSearchResults(results);
    setCurrentSearchResultIndex(results.length > 0 ? 0 : -1);
    
    if (results.length > 0) {
      // Scroll to first result
      scrollToMessage(results[0]);
    } else {
      toast({
        title: "No results found",
        description: `No messages containing "${searchQuery}" were found.`,
        variant: "default"
      });
    }
  };
  
  const scrollToMessage = (index: number) => {
    const messageElements = document.querySelectorAll('[data-message-index]');
    if (messageElements[index]) {
      messageElements[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  };
  
  const goToNextSearchResult = () => {
    if (searchResults.length === 0) return;
    
    const nextIndex = (currentSearchResultIndex + 1) % searchResults.length;
    setCurrentSearchResultIndex(nextIndex);
    scrollToMessage(searchResults[nextIndex]);
  };
  
  const goToPreviousSearchResult = () => {
    if (searchResults.length === 0) return;
    
    const prevIndex = (currentSearchResultIndex - 1 + searchResults.length) % searchResults.length;
    setCurrentSearchResultIndex(prevIndex);
    scrollToMessage(searchResults[prevIndex]);
  };
  
  const clearSearch = () => {
    setSearchQuery("");
    setIsSearching(false);
    setSearchResults([]);
    setCurrentSearchResultIndex(-1);
  };

  // Handle generated image
  const handleImageGenerated = (imageUrl: string) => {
    if (!imageUrl || !companion) {
      toast({
        title: "Error",
        description: "Failed to generate the image. Please try again.",
        variant: "destructive"
      });
      return;
    }
    
    console.log("Image generated successfully, adding to chat:", imageUrl.substring(0, 50) + "...");
    
    // Create a new message with the generated image
    const imageMessage: Message = {
      id: generateId(),
      content: `I created this image for you${companion ? ", hope you like it!" : "!"}`,
      sender: "companion",
      timestamp: new Date(),
      imageUrl: imageUrl
    };
    
    setMessages(prev => [...prev, imageMessage]);
    setShowImageGenerator(false);
    
    // Scroll to the new message
    setTimeout(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, 100);
  };

  return (
    <div className="flex flex-col h-screen bg-background">
      <Toaster />
      
      {/* Image Generator Modal */}
      {showImageGenerator && companion && (
        <ImageGenerator
          companion={companion}
          onImageGenerated={handleImageGenerated}
          onClose={() => setShowImageGenerator(false)}
        />
      )}
      
      {/* Profile Picture Popup Modal (WhatsApp Style) */}
      {showProfilePicture && companion && companion.imageUrl && (
        <div 
          className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center"
          onClick={() => setShowProfilePicture(false)}
        >
          <div 
            className="relative max-w-[90%] max-h-[90%] animate-in fade-in-50 zoom-in-95"
            onClick={(e) => e.stopPropagation()}
          >
            {/* Close button positioned at top right */}
            <Button 
              variant="ghost" 
              size="icon" 
              className="absolute top-4 right-4 text-white bg-black/50 hover:bg-black/70 rounded-full z-10"
              onClick={() => setShowProfilePicture(false)}
            >
              <X className="h-5 w-5" />
            </Button>
            
            {/* Main image */}
            <div className="rounded-lg overflow-hidden bg-black/20 flex items-center justify-center">
              <img 
                src={companion.imageUrl} 
                alt={companion.name} 
                className="max-w-full max-h-[80vh] object-contain shadow-xl" 
              />
            </div>
            
            {/* WhatsApp-style bottom info panel */}
            <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/90 to-black/0 p-4 text-white">
              <div className="flex items-center gap-3">
                <Avatar className="h-10 w-10 border-2 border-white">
                  <AvatarImage src={companion.imageUrl} alt={companion.name} className="object-cover" />
                  <AvatarFallback className="bg-primary text-primary-foreground">
                    {companion.name.charAt(0)}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <h2 className="font-semibold text-lg">{companion.name}</h2>
                  <div className="flex items-center gap-2 text-sm opacity-90">
                    {companion.gender && (
                      <span className="opacity-80">{companion.gender === 'female' ? 'Female' : 'Male'}</span>
                    )}
                    {companion.isPremium && (
                      <span className="bg-primary/80 text-white text-xs px-2 py-0.5 rounded-full">Premium</span>
                    )}
                  </div>
                </div>
              </div>
              {companion.tagline && (
                <p className="mt-2 text-sm opacity-90">{companion.tagline}</p>
              )}
            </div>
          </div>
        </div>
      )}
      
      {/* Settings Popup */}
      {showSettings && companion && (
        <CompanionSettingsPopup
          open={showSettings}
          onOpenChange={setShowSettings}
          companion={companion}
          isLoggedIn={!!user}
        />
      )}
      
      {/* Chat Header */}
      <header className="sticky top-0 z-10 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="container flex h-16 items-center justify-between py-4">
          <div className="flex items-center gap-4">
            <Button 
              variant="ghost" 
              size="icon"
              className="flex items-center justify-center"
              onClick={() => setLocation(user ? '/dashboard' : '/')}
            >
              <ArrowLeft className="h-5 w-5" />
            </Button>
            
            {isLoadingCompanion ? (
              <div className="flex items-center gap-2">
                <Skeleton className="h-10 w-10 rounded-full" />
                <Skeleton className="h-4 w-24" />
              </div>
            ) : (
              <div className="flex items-center gap-2">
                <Avatar 
                  className="h-10 w-10 flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-primary transition-all" 
                  onClick={() => setShowProfilePicture(true)}
                >
                  {companion?.imageUrl ? (
                    <AvatarImage 
                      src={companion.imageUrl} 
                      alt={companion.name}
                      className="object-cover"
                    />
                  ) : null}
                  <AvatarFallback>
                    {companion?.name ? companion.name.charAt(0) : '?'}
                  </AvatarFallback>
                </Avatar>
                <div className="flex flex-col justify-center">
                  <h2 className="text-sm font-medium">{companion?.name}</h2>
                  <p className="text-xs text-muted-foreground">{companion?.tagline}</p>
                </div>
              </div>
            )}
          </div>
          
          <div className="flex items-center gap-2">
            {!isSearching && (
              user && userPrefs ? (
                <DiamondCounter 
                  count={userPrefs.messageDiamonds || 0} 
                  className="mr-2" 
                />
              ) : (
                <DiamondCounter 
                  count={100 - guestMessageCount} 
                  className="mr-2" 
                />
              )
            )}
            
            {!isSearching ? (
              <Button 
                variant="outline" 
                size="icon"
                className="flex items-center justify-center h-10 w-10"
                onClick={() => setIsSearching(true)}
                title="Search messages"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-search">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.3-4.3"></path>
                </svg>
              </Button>
            ) : (
              <div className="flex items-center bg-muted rounded-md border border-input overflow-hidden">
                <input
                  type="text"
                  placeholder="Search messages"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="bg-transparent focus:outline-none px-3 py-1 min-w-[120px] sm:min-w-[180px] text-sm"
                  autoFocus
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      handleSearch();
                    } else if (e.key === 'Escape') {
                      clearSearch();
                    }
                  }}
                />
                <div className="flex">
                  <Button 
                    variant="secondary" 
                    size="icon"
                    className="h-8 w-8 flex items-center justify-center"
                    onClick={goToPreviousSearchResult}
                    disabled={searchResults.length === 0}
                    title="Previous result"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-chevron-up">
                      <path d="m18 15-6-6-6 6"></path>
                    </svg>
                  </Button>
                  <Button 
                    variant="secondary" 
                    size="icon"
                    className="h-8 w-8 flex items-center justify-center"
                    onClick={goToNextSearchResult}
                    disabled={searchResults.length === 0}
                    title="Next result"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-chevron-down">
                      <path d="m6 9 6 6 6-6"></path>
                    </svg>
                  </Button>
                  <Button 
                    variant="secondary" 
                    size="icon"
                    className="h-8 w-8 flex items-center justify-center"
                    onClick={clearSearch}
                    title="Close search"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-x">
                      <path d="M18 6 6 18"></path>
                      <path d="m6 6 12 12"></path>
                    </svg>
                  </Button>
                </div>
              </div>
            )}
            
            {user ? (
              <Button 
                variant="outline" 
                size="icon"
                className="flex items-center justify-center h-10 w-10"
                onClick={() => setShowSettings(true)}
                title="Companion settings"
              >
                <Settings className="h-5 w-5" />
              </Button>
            ) : (
              <Button 
                variant="outline" 
                size="icon"
                className="flex items-center justify-center h-10 w-10"
                onClick={() => setShowSettings(true)}
                title="Companion settings (limited in guest mode)"
              >
                <Settings className="h-5 w-5" />
              </Button>
            )}
          </div>
        </div>
      </header>
      
      {/* Chat Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((msg, index) => (
          <div
            key={msg.id}
            data-message-index={index}
            className={`flex ${msg.sender === 'user' ? 'justify-end' : 'justify-start'} items-end gap-2 ${
              searchResults.includes(index) && 
              searchResults[currentSearchResultIndex] === index ? 
              'bg-yellow-100/20 rounded-xl px-1 pt-1 -mx-1 -mt-1' : ''
            }`}
          >
            {/* Companion Avatar - WhatsApp style */}
            {msg.sender === 'companion' && companion && (
              <Avatar 
                className="h-8 w-8 flex-shrink-0 cursor-pointer hover:ring-2 hover:ring-primary/50 transition-all" 
                onClick={() => setShowProfilePicture(true)}
              >
                {companion.imageUrl ? (
                  <AvatarImage 
                    src={companion.imageUrl} 
                    alt={companion.name}
                    className="object-cover"
                  />
                ) : null}
                <AvatarFallback>
                  {companion.name ? companion.name.charAt(0) : '?'}
                </AvatarFallback>
              </Avatar>
            )}
            
            {/* Message bubble */}
            <div 
              className={`relative max-w-[80%] md:max-w-[70%] rounded-2xl p-3 
                ${msg.sender === 'user' 
                  ? 'bg-primary text-primary-foreground rounded-tr-none' 
                  : 'bg-muted border border-border rounded-tl-none'
                } ${
                  searchResults.includes(index) ? 'ring-2 ring-yellow-400/70 ring-offset-2' : ''
                }`}
            >
              {/* Message content */}
              <p className="text-sm mb-1 whitespace-pre-wrap">{msg.content}</p>
              
              {/* Generated image (if present) */}
              {msg.imageUrl && (
                <div className="mt-2 mb-3 rounded-md overflow-hidden border border-border">
                  <img 
                    src={msg.imageUrl} 
                    alt="Generated" 
                    className="max-w-full max-h-[300px] h-auto object-contain rounded-md" 
                    onClick={() => window.open(msg.imageUrl, '_blank')}
                    style={{ cursor: 'pointer' }}
                  />
                </div>
              )}
              
              {/* Message footer with emotion and timestamp */}
              <div className="flex items-center justify-end gap-2 mt-1">
                {msg.emotion && (
                  <EmotionIndicator 
                    emotion={msg.emotion} 
                    isPremium={companion?.isPremium === true}
                    size="sm"
                    showDetails={true}
                  />
                )}
                <p className="text-xs opacity-70">
                  {msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </p>
              </div>
            </div>
            
            {/* User Avatar */}
            {msg.sender === 'user' && (
              <Avatar className="h-8 w-8 flex-shrink-0">
                <AvatarFallback>
                  <User2 className="h-4 w-4" />
                </AvatarFallback>
              </Avatar>
            )}
          </div>
        ))}
        
        {isLoading && (
          <div className="flex justify-start">
            <div className="max-w-[80%] md:max-w-[70%] rounded-2xl p-3 bg-muted border border-border">
              <div className="flex items-center gap-3">
                <Avatar 
                  className="h-8 w-8 cursor-pointer hover:ring-2 hover:ring-primary transition-all"
                  onClick={() => setShowProfilePicture(true)}
                >
                  {companion?.imageUrl ? <AvatarImage src={companion.imageUrl} /> : null}
                  <AvatarFallback>
                    {companion?.name ? companion.name.charAt(0) : '?'}
                  </AvatarFallback>
                </Avatar>
                <div className="typing-indicator flex items-center">
                  <span className="typing-dot h-2 w-2 mx-[1px] bg-muted-foreground/30 rounded-full animate-typing-1"></span>
                  <span className="typing-dot h-2 w-2 mx-[1px] bg-muted-foreground/30 rounded-full animate-typing-2"></span>
                  <span className="typing-dot h-2 w-2 mx-[1px] bg-muted-foreground/30 rounded-full animate-typing-3"></span>
                </div>
              </div>
            </div>
          </div>
        )}
        
        <div ref={messagesEndRef} />
      </div>
      
      {/* Message Input */}
      <div className="border-t bg-background p-4">
        <div className="container mx-auto flex items-center gap-2">
          <Button 
            variant="outline" 
            size="icon" 
            className="shrink-0 h-10 w-10 flex items-center justify-center"
            type="button"
            onClick={() => setShowImageGenerator(true)}
          >
            <ImagePlus className="h-5 w-5 text-muted-foreground" />
          </Button>
          
          <Textarea
            placeholder="Type a message..."
            className="min-h-10 flex-1 resize-none py-2"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            onKeyDown={handleKeyDown}
          />
          
          <Button 
            variant="default"
            size="icon" 
            className="shrink-0 h-10 w-10 flex items-center justify-center bg-primary hover:bg-primary/90"
            onClick={handleSendMessage}
            disabled={isLoading || !message.trim()}
          >
            <Send className="h-5 w-5" />
          </Button>
        </div>
      </div>
    </div>
  );
}